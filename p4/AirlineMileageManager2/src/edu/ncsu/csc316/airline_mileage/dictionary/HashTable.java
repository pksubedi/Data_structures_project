/**
 * Package for this class.
 */
package edu.ncsu.csc316.airline_mileage.dictionary;

/**
 * HashTable data structure
 * @author PremSubedi
 * @param <E> generic parameter
 *
 */
public class HashTable<E> implements Dictionary<E> {
	private static final double GOLDEN_RATIO = 0.61803399;

	private int size;

	@SuppressWarnings({ "rawtypes" })
	private ArrayBasedList<Bucket> bucketList;

	private int capacity;
	private double loadFactor;
	/**
	 * Returns size of the hash table.
	 * @return size the size.
	 */
	public int getSize() {
		return size;
	}
	
	/**
	 * Returns value stored in bucket.
	 * @param e index for bucket.
	 * @return E an object to be returned.
	 */
	@SuppressWarnings("unchecked")
	public E get(E e) {
		if(lookUp(e)) return (E) bucketList.get(compress(e.hashCode()));
		return null;
	}


	/**
	 * HashTable constructor.
	 * @param n number of entry in the hash table.
	 */
	@SuppressWarnings("rawtypes")
	public HashTable(int n) {
		this.capacity = n;
		loadFactor = 0.5;
		size = 0;
		bucketList = new ArrayBasedList<Bucket>(n);
	}

	@SuppressWarnings("unchecked")
	@Override
	public boolean lookUp(E e) {

		int idx = compress(e.hashCode());
		Bucket<E> temp = bucketList.get(idx);
		while (temp != null) {
			if (temp.value.equals(e)) {
				return true;
			}
			temp = temp.next;
		}
		return false;
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	@Override
	public void insert(E e) {
		int idx = compress(e.hashCode());

		if (bucketList.get(idx) == null) {
			Bucket<E> bucket = new Bucket<E>(e);
			bucketList.add(idx, (Bucket<E>) bucket);
			size++;
		} else {
			Bucket<E> temp = bucketList.get(idx);
			while (temp.next != null) {
				temp = temp.next;
			}
			temp.next = new Bucket<E>(e);
		}

		loadFactor = (double) size / capacity;
		if(loadFactor > 0.5 ) {
			capacity *= 2;
			size = 0;
			ArrayBasedList<Bucket> newList = new ArrayBasedList<Bucket>(capacity);
			for(int i = 0; i < bucketList.size(); i++) {
				if(bucketList.get(i) != null) {
					int index = compress(bucketList.get(i).value.hashCode());
					if (newList.get(index) == null) {
						Bucket<E> bucket2 = new Bucket<E>((E) bucketList.get(i).value);
						newList.add(index, (Bucket<E>) bucket2);
						size++;
					} else {
						Bucket<E> temp = newList.get(index);
						while (temp.next != null) {
							temp = temp.next;
						}
						temp.next = new Bucket<E>((E) bucketList.get(i).value);
					}
				} 
			}
			bucketList = newList;
		}
	}


	/**
	 * This method compresses the hash code to fit in the hash table
	 * 
	 * @param hashCode hashCode generated by hashing function
	 * @return compressedValue a value that is compressed to be returned.
	 */
	private int compress(long hashCode) {
		int compressedValue = (int) Math.floor(capacity * ((hashCode * GOLDEN_RATIO) - Math.floor(hashCode * GOLDEN_RATIO)));
		return compressedValue;
	}


	/**
	 * Inner class which represents each bucket of list representing each 
	 * index of the HashTable.
	 * @author PremSubedi
	 * @param <E> generic parameter
	 */
	@SuppressWarnings("hiding")
	public class Bucket<E> {
		E value;
		Bucket<E> next;

		/**
		 * Bucket constructor which initializes it's fields.
		 * @param e compressed value of an object.
		 */
		public Bucket(E e) {
			this.value = e;
			this.next = null;
		}
	}

}
